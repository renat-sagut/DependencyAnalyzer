# dependency-analyzer

## Формулировка задачи
Нужно написать анализатор файлов исходного кода на С++. Программа должна выводить дерево зависимостей и частоты включений файлов. Если найдены включения несуществующих файлов, то программа должна вывести пометку «(!)» после имени файла.

В директории с исходными кодами могут быть вложенные папки (то есть обход должен производиться рекурсивно). Файлы имеют расширения ".h" и ".cpp"
##Требования к выполнению задачи 
1.	Задача выполняется на С++ (стандарт C++03 или C++11 на выбор)
2.	Разрешается (и приветствуется) использование стандартной библиотеки языка С, стандартной библиотеки шаблонов (STL) и библиотеки BOOST
3.	Программа должна являться консольным приложением
4.	Программа должна собираться под Windows при помощи компилятора Microsoft Visual C++ (желательно MSVC 2010) и под Linux – с помощью компилятора GCC.
5.	Решение должно состоять из документа, описывающего реализацию, исходных кодов программы и исполняемого модуля, демонстрирующего работу класса.

## Входные параметры
В качестве аргументов командной строки получает путь к каталогу с исходниками и пути для поиска заголовочных файлов (то есть файлы, включенные директивой вида #include <a.h> должны искаться в каталогах, указанных в параметрах командной строки)

```
analyser <sources path> [options]
```

Опции:

-I – путь для поиска исходных файлов

Пример вызова программы:

```
analyser c:\mysources\ -I c:\mysources\includes -I c:\mylibrary
```

(программа должна проанализировать исходники в каталоге c:\mysources, используя следующие пути для поиска заголовочных файлов: "c:\mysources\include" и "c:\mylibrary")
##Вывод результата
Программа должна выводить дерево зависимостей исходных файлов и список файлов с частотами их включения в другие файлы.
Список частот включений файлов должен быть отсортирован в порядке убывания частоты; записи с одинаковым значением частоты сортируются по алфавиту. Список частот отделён от дерева зависимостей пустой строкой.

Пример вывода:
```
test.cpp
..a.h
....foo.h
....b.h
......foo.h
..test.h
....foo.h
..deleted.h (!)
main.cpp
..test.h
....foo.h

foo.h 4
test.h 2
a.h 1
b.h 1
deleted.h 1
main.cpp 0
test.cpp 0
```
##Примечания
1.	Необходимо учитывать, что директивы #include могут быть закомментированы
2.	Утилита должна работать в соответствии с правилами работы препроцессора С++: если имя файла заключено в кавычки, то поиск производится относительно пути к обрабатываемому файлу; если оно заключено в "<>", то файл ищется в путях, указанных в агрументах при запуске программы
  ```
  #include "foo.h"
  
  #include <test/aa.h>
  
  /*
  #include <c.h>
  */
  
  ```
В данном примере включены файлы foo.h и test/aa.h; файл c.h не включен. Поиск файла foo.h производится в текущей директории, а файла test/aa.h - в директориях, заданных в аргументах командной строки.
3.	Желательно предусмотреть обработку циклических зависимостей

